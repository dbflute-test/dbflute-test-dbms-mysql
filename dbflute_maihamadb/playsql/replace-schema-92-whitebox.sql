
-- =======================================================================================
--                                                                         Colorful Schema 
--                                                                         ===============
-- /= = = = = = = = = = = = = = = = = = = = = =
-- for the test of only one-to-one table
-- = = = = = = = = = =/
create table WHITE_ONLY_ONE_TO_ONE_FROM(
    FROM_ID BIGINT AUTO_INCREMENT NOT NULL,
    FROM_NAME VARCHAR(200) NOT NULL,
    PRIMARY KEY (FROM_ID)
);

create table WHITE_ONLY_ONE_TO_ONE_TO(
    TO_ID BIGINT AUTO_INCREMENT NOT NULL,
    TO_NAME VARCHAR(200) NOT NULL,
    FROM_ID BIGINT NOT NULL,
    PRIMARY KEY (TO_ID),
    UNIQUE (FROM_ID)
);

alter table WHITE_ONLY_ONE_TO_ONE_TO add constraint FK_WHITE_ONLY_ONE_TO_ONE_TO_FROM
	foreign key (FROM_ID)
	REFERENCES WHITE_ONLY_ONE_TO_ONE_FROM (FROM_ID);


-- /= = = = = = = = = = = = = = = = = = = = = = = =
-- for the test of non-unique relationship
-- = = = = = = = = = =/
create table WHITE_NON_UNIQUE_MANY_TO_ONE_FROM(
    FROM_ID BIGINT AUTO_INCREMENT NOT NULL,
    FROM_NAME VARCHAR(200) NOT NULL,
    NON_UNIQUE_CODE CHAR(3) NOT NULL,
    BEGIN_DATE DATE NOT NULL,
    END_DATE DATE NOT NULL,
    MANY_POINT INTEGER NOT NULL,
    PRIMARY KEY (FROM_ID)
);

create table WHITE_NON_UNIQUE_MANY_TO_ONE_TO(
    TO_ID BIGINT AUTO_INCREMENT NOT NULL,
    TO_NAME VARCHAR(200) NOT NULL,
    NON_UNIQUE_CODE CHAR(3) NOT NULL,
    BEGIN_DATE DATE NOT NULL,
    END_DATE DATE NOT NULL,
    PRIMARY KEY (TO_ID)
);


-- /= = = = = = = = = = = = = = = = = = = = = =
-- for the test of over relation, referrer over
-- = = = = = = = = = =/
create table WHITE_PURCHASE_REFERRER(
    PURCHASE_REFERRER_ID BIGINT AUTO_INCREMENT NOT NULL,
    PURCHASE_REFERRER_NAME VARCHAR(200) NOT NULL,
    PRIMARY KEY (PURCHASE_REFERRER_ID)
);

alter table WHITE_PURCHASE_REFERRER add constraint FK_WHITE_PURCHASE_REFERRER
	foreign key (PURCHASE_REFERRER_ID)
	REFERENCES PURCHASE (PURCHASE_ID);

-- /= = = = = = = = = = = = = = = = = = = = = = = =
-- for the test of over relation, split multiple FK
-- = = = = = = = = = =/
create table WHITE_SPLIT_MULTIPLE_FK_BASE(
    BASE_ID BIGINT NOT NULL,
    FIRST_ID INTEGER NOT NULL,
    NEXT_ID BIGINT NOT NULL,
    SPLIT_NAME VARCHAR(200) NOT NULL,
    PRIMARY KEY (BASE_ID)
);

create table WHITE_SPLIT_MULTIPLE_FK_NEXT(
    NEXT_ID BIGINT NOT NULL,
    SECOND_CODE CHAR(3) NOT NULL,
    PRIMARY KEY (NEXT_ID)
);

create table WHITE_SPLIT_MULTIPLE_FK_REF(
    FIRST_ID INTEGER NOT NULL,
    SECOND_CODE CHAR(3) NOT NULL,
    REF_NAME VARCHAR(200) NOT NULL,
    PRIMARY KEY (FIRST_ID, SECOND_CODE)
);

create table WHITE_SPLIT_MULTIPLE_FK_CHILD(
    CHILD_ID BIGINT NOT NULL,
    BASE_ID BIGINT NOT NULL,
    CHILD_NAME VARCHAR(200) NOT NULL,
    PRIMARY KEY (CHILD_ID)
);

alter table WHITE_SPLIT_MULTIPLE_FK_BASE add constraint FK_WHITE_SPLIT_MULTIPLE_FK_NEXT
	foreign key (NEXT_ID)
	REFERENCES WHITE_SPLIT_MULTIPLE_FK_NEXT (NEXT_ID) ;

alter table WHITE_SPLIT_MULTIPLE_FK_CHILD add constraint FK_WHITE_SPLIT_MULTIPLE_FK_BASE
	foreign key (BASE_ID)
	REFERENCES WHITE_SPLIT_MULTIPLE_FK_BASE (BASE_ID) ;

-- /= = = = = = = = = = = = = = = = = =
-- for the test of implicit reverse FK
-- = = = = = = = = = =/
create table WHITE_IMPLICIT_REVERSE_FK(
    WHITE_IMPLICIT_REVERSE_FK_ID INTEGER AUTO_INCREMENT NOT NULL,
    WHITE_IMPLICIT_REVERSE_FK_NAME VARCHAR(200) NOT NULL,
    PRIMARY KEY (WHITE_IMPLICIT_REVERSE_FK_ID)
);

create table WHITE_IMPLICIT_REVERSE_FK_REF(
    WHITE_IMPLICIT_REVERSE_FK_REF_ID INTEGER AUTO_INCREMENT NOT NULL,
    WHITE_IMPLICIT_REVERSE_FK_ID INTEGER NOT NULL,
    VALID_BEGIN_DATE DATE NOT NULL,
    VALID_END_DATE DATE NOT NULL,
    PRIMARY KEY (WHITE_IMPLICIT_REVERSE_FK_REF_ID),
    UNIQUE (WHITE_IMPLICIT_REVERSE_FK_ID, VALID_BEGIN_DATE)
);

create table WHITE_IMPLICIT_REVERSE_FK_SUPPRESS(
    WHITE_IMPLICIT_REVERSE_FK_SUPPRESS_ID INTEGER AUTO_INCREMENT NOT NULL,
    WHITE_IMPLICIT_REVERSE_FK_ID INTEGER NOT NULL,
    VALID_BEGIN_DATE DATE NOT NULL,
    VALID_END_DATE DATE NOT NULL,
    PRIMARY KEY (WHITE_IMPLICIT_REVERSE_FK_SUPPRESS_ID),
    UNIQUE (WHITE_IMPLICIT_REVERSE_FK_ID, VALID_BEGIN_DATE)
);

-- /= = = = = = = = = = = = = = = = = = = =
-- for the test of compound primary key
-- = = = = = = = = = =/
create table WHITE_COMPOUND_PK (
	PK_FIRST_ID INTEGER NOT NULL,
	PK_SECOND_ID INTEGER NOT NULL,
	COMPOUND_PK_NAME VARCHAR(200) NOT NULL,
	REFERRED_ID INTEGER NOT NULL,
	PRIMARY KEY (PK_FIRST_ID, PK_SECOND_ID),
	UNIQUE (PK_SECOND_ID, REFERRED_ID),
	UNIQUE (PK_SECOND_ID, PK_FIRST_ID)
) ;

create table WHITE_COMPOUND_PK_REF (
	MULTIPLE_FIRST_ID INTEGER NOT NULL,
	MULTIPLE_SECOND_ID INTEGER NOT NULL,
	REF_FIRST_ID INTEGER NOT NULL,
	REF_SECOND_ID INTEGER NOT NULL,
	REF_NAME VARCHAR(50) NOT NULL,
	PRIMARY KEY (MULTIPLE_FIRST_ID, MULTIPLE_SECOND_ID)
) ;

alter table WHITE_COMPOUND_PK_REF add constraint FK_WHITE_COMPOUND_PK_REF
	foreign key (REF_FIRST_ID, REF_SECOND_ID)
	REFERENCES WHITE_COMPOUND_PK (PK_FIRST_ID, PK_SECOND_ID) ;

-- for the test of multiple compound key
create table WHITE_COMPOUND_PK_REF_NEST (
	COMPOUND_PK_REF_NEST_ID INTEGER NOT NULL PRIMARY KEY,
	FOO_MULTIPLE_ID INTEGER NOT NULL,
	BAR_MULTIPLE_ID INTEGER NOT NULL,
	QUX_MULTIPLE_ID INTEGER NOT NULL,
	NEST_NAME VARCHAR(50) NOT NULL
) ;

alter table WHITE_COMPOUND_PK_REF_NEST add constraint FK_WHITE_COMPOUND_PK_REF_NEST_FOO_BAR
	foreign key (FOO_MULTIPLE_ID, BAR_MULTIPLE_ID)
	REFERENCES WHITE_COMPOUND_PK_REF (MULTIPLE_FIRST_ID, MULTIPLE_SECOND_ID) ;

alter table WHITE_COMPOUND_PK_REF_NEST add constraint FK_WHITE_COMPOUND_PK_REF_NEST_BAR_QUX
	foreign key (BAR_MULTIPLE_ID, QUX_MULTIPLE_ID)
	REFERENCES WHITE_COMPOUND_PK_REF (MULTIPLE_FIRST_ID, MULTIPLE_SECOND_ID) ;

-- for the test of correlated fixed condition
create table WHITE_COMPOUND_PK_REF_MANY (
	MULTIPLE_FIRST_ID INTEGER NOT NULL,
	MULTIPLE_SECOND_ID INTEGER NOT NULL,
	REF_MANY_FIRST_ID INTEGER NOT NULL,
	REF_MANY_SECOND_ID INTEGER NOT NULL,
	REF_MANY_CODE CHAR(3) NOT NULL,
	REF_MANY_NAME VARCHAR(50) NOT NULL,
	REF_MANY_DATETIME DATETIME NOT NULL,
	PRIMARY KEY (MULTIPLE_FIRST_ID, MULTIPLE_SECOND_ID)
) ;

-- for the test of biz-many-to-one with compound reference
-- defined by additionalForeignKeyMap_manytoone.dfprop
create table WHITE_COMPOUND_REFERRED_NORMALLY (
	REFERRED_ID INTEGER NOT NULL,
	REFERRED_NAME VARCHAR(200) NOT NULL,
	PRIMARY KEY (REFERRED_ID)
) ;

create table WHITE_COMPOUND_REFERRED_PRIMARY (
	REFERRED_ID INTEGER NOT NULL,
	REFERRED_NAME VARCHAR(200) NOT NULL,
	PRIMARY KEY (REFERRED_ID)
) ;

-- for test of wrong-ordered compound PK
create table WHITE_COMPOUND_PK_WRONG_ORDER (
	FIRST_ID INTEGER NOT NULL,
	SECOND_ID INTEGER NOT NULL,
	THIRD_ID INTEGER NOT NULL,
	WRONG_NAME VARCHAR(200) NOT NULL,
	PRIMARY KEY (SECOND_ID, THIRD_ID, FIRST_ID)
) ;

-- /= = = = = = = = = = = = = = = 
-- for the test of unique-key FK
-- = = = = = = = = = =/
create table WHITE_UQ_FK (
	UQ_FK_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	UQ_FK_CODE CHAR(3) NOT NULL,
	UNIQUE (UQ_FK_CODE)
) ;

create table WHITE_UQ_FK_REF (
	UQ_FK_REF_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	FK_TO_PK_ID NUMERIC(16) NOT NULL,
	FK_TO_UQ_CODE CHAR(3) NOT NULL,
	COMPOUND_UQ_FIRST_CODE CHAR(3) NOT NULL,
	COMPOUND_UQ_SECOND_CODE CHAR(3) NOT NULL,
	UNIQUE (COMPOUND_UQ_FIRST_CODE, COMPOUND_UQ_SECOND_CODE)
) ;

alter table WHITE_UQ_FK_REF add constraint FK_WHITE_UQ_FK_REF_PK
	foreign key (FK_TO_PK_ID) references WHITE_UQ_FK (UQ_FK_ID) ;

alter table WHITE_UQ_FK_REF add constraint FK_WHITE_UQ_FK_REF_UQ
	foreign key (FK_TO_UQ_CODE) references WHITE_UQ_FK (UQ_FK_CODE) ;

-- for the test of compound unique key
-- and the test of same name key
create table WHITE_UQ_FK_REF_NEST (
	UQ_FK_REF_NEST_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	COMPOUND_UQ_FIRST_CODE CHAR(3) NOT NULL,
	COMPOUND_UQ_SECOND_CODE CHAR(3) NOT NULL
) ;

alter table WHITE_UQ_FK_REF_NEST add constraint FK_WHITE_UQ_FK_REF_NEST_UQ
	foreign key (COMPOUND_UQ_FIRST_CODE, COMPOUND_UQ_SECOND_CODE)
	REFERENCES WHITE_UQ_FK_REF (COMPOUND_UQ_FIRST_CODE, COMPOUND_UQ_SECOND_CODE) ;

create table WHITE_UQ_FK_WITHOUT_PK (
	UQ_FK_CODE CHAR(3) NOT NULL,
	UQ_FK_NAME VARCHAR(64) NOT NULL,
	UNIQUE (UQ_FK_CODE)
) ;

create table WHITE_UQ_FK_WITHOUT_PK_REF (
	UQ_FK_REF_ID NUMERIC(16) NOT NULL,
	FK_TO_UQ_CODE CHAR(3) NOT NULL
) ;

alter table WHITE_UQ_FK_WITHOUT_PK_REF add constraint FK_WHITE_UQ_FK_WITHOUT_PK_REF
	foreign key (FK_TO_UQ_CODE) references WHITE_UQ_FK_WITHOUT_PK (UQ_FK_CODE) ;

-- /= = = = = = = = = = = = = = = = = = = = = = 
-- for the test of unique key as classification
-- = = = = = = = = = =/
create table WHITE_UQ_CLASSIFICATION (
	UQ_CLS_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	UQ_CLS_CODE CHAR(3) NOT NULL,
	UNIQUE (UQ_CLS_CODE)
) ;

create table WHITE_UQ_CLASSIFICATION_FLG (
	UQ_CLS_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	UQ_CLS_FLG INTEGER NOT NULL,
	UNIQUE (UQ_CLS_FLG)
) ;

create table WHITE_UQ_CLASSIFICATION_FLG_BIT (
	UQ_CLS_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	UQ_CLS_NAME VARCHAR(30) NOT NULL,
	UQ_CLS_BIT_FLG BIT NOT NULL,
	UNIQUE (UQ_CLS_NAME, UQ_CLS_BIT_FLG)
) ;

create table WHITE_UQ_CLASSIFICATION_FLG_PART (
	UQ_CLS_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	UQ_CLS_NAME VARCHAR(30) NOT NULL,
	UQ_CLS_FLG INTEGER NOT NULL,
	UNIQUE (UQ_CLS_NAME, UQ_CLS_FLG)
) ;

-- /= = = = = = = = = = = = = = = = = = 
-- for the test of no-primary-key table
-- = = = = = = = = = =/
create table WHITE_NO_PK (
	NO_PK_ID NUMERIC(16) NOT NULL,
	NO_PK_NAME VARCHAR(32),
	NO_PK_INTEGER INTEGER
) ;

create table WHITE_NO_PK_COMMON_COLUMN (
	NO_PK_ID NUMERIC(16) NOT NULL,
	NO_PK_NAME VARCHAR(32),
	NO_PK_INTEGER INTEGER,
    REGISTER_DATETIME DATETIME NOT NULL COMMENT '登録日時: レコードが登録された日時。共通カラムの一つ。',
    REGISTER_USER VARCHAR(200) NOT NULL COMMENT '登録ユーザ: レコードを登録したユーザ。共通カラムの一つ。',
    UPDATE_DATETIME DATETIME NOT NULL COMMENT '更新日時: レコードが（最後に）更新された日時。共通カラムの一つ。',
    UPDATE_USER VARCHAR(200) NOT NULL COMMENT '更新ユーザ: レコードを更新したユーザ。'
) ;

CREATE VIEW WHITE_NO_PK_RELATION as
select product.PRODUCT_ID
     , product.PRODUCT_NAME
     , product.PRODUCT_HANDLE_CODE
     , product.PRODUCT_STATUS_CODE
     , (select max(purchase.PURCHASE_DATETIME)
          from PURCHASE purchase
         where purchase.PRODUCT_ID = product.PRODUCT_ID
       ) as LATEST_PURCHASE_DATETIME
  from PRODUCT product
;

-- /= = = = = = = = = = = = = = = = = = = = = = = = = = =
-- for the test of variant relation (biz-many-to-one)
-- = = = = = = = = = =/
create table WHITE_VARIANT_RELATION_MASTER_FOO(
    MASTER_FOO_ID BIGINT NOT NULL,
    MASTER_FOO_NAME VARCHAR(200) NOT NULL,
    PRIMARY KEY (MASTER_FOO_ID)
);

create table WHITE_VARIANT_RELATION_MASTER_BAR(
    MASTER_BAR_ID BIGINT NOT NULL,
    MASTER_BAR_NAME VARCHAR(200) NOT NULL,
    PRIMARY KEY (MASTER_BAR_ID)
);

create table WHITE_VARIANT_RELATION_MASTER_QUX(
    MASTER_QUX_ID BIGINT NOT NULL,
    MASTER_QUX_NAME VARCHAR(200) NOT NULL,
    QUX_TYPE_CODE CHAR(3) NOT NULL,
    PRIMARY KEY (MASTER_QUX_ID)
);

create table WHITE_VARIANT_RELATION_MASTER_CORGE(
    MASTER_CORGE_ID BIGINT NOT NULL,
    MASTER_CORGE_NAME VARCHAR(200) NOT NULL,
    CORGE_TYPE_CODE CHAR(3) NOT NULL,
    PRIMARY KEY (MASTER_CORGE_ID)
);

create table WHITE_VARIANT_RELATION_REFERRER(
    REFERRER_ID BIGINT NOT NULL,
    VARIANT_MASTER_ID BIGINT NOT NULL,
    MASTER_TYPE_CODE CHAR(3) NOT NULL,
    PRIMARY KEY (REFERRER_ID)
);

create table WHITE_VARIANT_RELATION_REFERRER_REF(
    REF_ID BIGINT NOT NULL,
    REFERRER_ID BIGINT NOT NULL,
    PRIMARY KEY (REF_ID)
);

alter table WHITE_VARIANT_RELATION_REFERRER_REF add constraint FK_WHITE_VARIANT_RELATION_REFERRER_REF
	foreign key (REFERRER_ID) references WHITE_VARIANT_RELATION_REFERRER (REFERRER_ID) ;

create table WHITE_VARIANT_RELATION_LOCAL_PK_REFERRER(
    REVERSEFK_SUPPRESSED_ID BIGINT NOT NULL,
    MASTER_TYPE_CODE CHAR(3) NOT NULL,
    PRIMARY KEY (REVERSEFK_SUPPRESSED_ID)
);

-- /= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
-- for the test of all-in-one table classification (biz-many-to-one)
-- = = = = = = = = = =/
create table WHITE_ALL_IN_ONE_CLS_CATEGORY (
	CLS_CATEGORY_CODE CHAR(3) NOT NULL,
	CLS_CATEGORY_NAME VARCHAR(20) NOT NULL,
	DESCRIPTION VARCHAR(200) NOT NULL,
	PRIMARY KEY (CLS_CATEGORY_CODE)
) ;

create table WHITE_ALL_IN_ONE_CLS_ELEMENT (
	CLS_CATEGORY_CODE CHAR(3) NOT NULL,
	CLS_ELEMENT_CODE CHAR(3) NOT NULL,
	CLS_ELEMENT_NAME VARCHAR(20) NOT NULL,
	ATTRIBUTE_EXP TEXT NOT NULL,
	PRIMARY KEY (CLS_CATEGORY_CODE, CLS_ELEMENT_CODE)
) ;

alter table WHITE_ALL_IN_ONE_CLS_ELEMENT add constraint FK_WHITE_ALL_IN_ONE_CLS_ELEMENT_CATEGORY
	foreign key (CLS_CATEGORY_CODE)
	REFERENCES WHITE_ALL_IN_ONE_CLS_CATEGORY (CLS_CATEGORY_CODE) ;

-- also for the test of no implicit reverse FK
create table WHITE_ALL_IN_ONE_CLS_COMPOUND_PK_REF (
	FOO_CODE CHAR(3) NOT NULL,
	BAR_CODE CHAR(3) NOT NULL,
	QUX_CODE CHAR(3) NOT NULL,
	PRIMARY KEY (FOO_CODE, BAR_CODE, QUX_CODE)
) ;

create table WHITE_ALL_IN_ONE_CLS_NORMAL_COL_REF (
	CLS_REF_ID INTEGER NOT NULL,
	FOO_CODE CHAR(3) NOT NULL,
	BAR_CODE CHAR(3) NOT NULL,
	QUX_CODE CHAR(3) NOT NULL,
	PRIMARY KEY (FOO_CODE, BAR_CODE, QUX_CODE)
) ;

-- /= = = = = = = = = = = = = = = = = = = = = = = = = = =
-- for the test of columnExcept on databaseInfoMap.dfprop
-- = = = = = = = = = =/
create table WHITE_COLUMN_EXCEPT (
	EXCEPT_COLUMN_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	COLUMN_EXCEPT_TEST INTEGER -- actually NOT except
) ;

create table WHITE_COLUMN_EXCEPT_GEN_ONLY (
	GEN_ONLY_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	GEN_ONLY_NAME VARCHAR(200) NOT NULL,
	THIS_IS_GEN_ONLY VARCHAR(200)
) ;

-- /= = = = = = = = = = = = = = = = = = =
-- for the test of MyselfInScopeSubQuery
-- = = = = = = = = = =/
create table WHITE_MYSELF (
	MYSELF_ID integer NOT NULL PRIMARY KEY,
	MYSELF_NAME varchar(80) NOT NULL
) ;

create table WHITE_MYSELF_CHECK ( 
	MYSELF_CHECK_ID integer NOT NULL PRIMARY KEY,
	MYSELF_CHECK_NAME varchar(80) NOT NULL,
	MYSELF_ID integer
) ;

alter table WHITE_MYSELF_CHECK add constraint FK_WHITE_MYSELF_CHECK_SELF
	foreign key (MYSELF_ID) references WHITE_MYSELF (MYSELF_ID) ;

-- /= = = = = = = = = = = = = = = = = = 
-- for the test of self reference
-- = = = = = = = = = =/
create table WHITE_SELF_REFERENCE (
	SELF_REFERENCE_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	SELF_REFERENCE_NAME VARCHAR(200) NOT NULL,
	PARENT_ID NUMERIC(16)
) ;

alter table WHITE_SELF_REFERENCE add constraint FK_WHITE_SELF_REFERENCE_PARENT
	foreign key (PARENT_ID) references WHITE_SELF_REFERENCE (SELF_REFERENCE_ID) ;

create table WHITE_SELF_REFERENCE_REF_ONE (
	SELF_REFERENCE_ID NUMERIC(16) NOT NULL PRIMARY KEY,
	SELF_REFERENCE_REF_ONE_NAME VARCHAR(200) NOT NULL
) ;

alter table WHITE_SELF_REFERENCE_REF_ONE add constraint FK_WHITE_SELF_REFERENCE_REF_ONE
	foreign key (SELF_REFERENCE_ID) references WHITE_SELF_REFERENCE (SELF_REFERENCE_ID) ;

-- /= = = = = = = = = = = = = = = = = = = = = = = = =
-- for the test of binary data type (e.g. image file)
-- = = = = = = = = = =/
create table WHITE_BINARY (
	BINARY_ID BIGINT AUTO_INCREMENT NOT NULL,
	BINARY_DATA BINARY,
	BLOB_DATA BLOB,
	PRIMARY KEY (BINARY_ID)
) ;


